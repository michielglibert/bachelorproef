%%=============================================================================
%% React VR
%%=============================================================================
\chapter{React 360}
\label{ch:react-360}

React 360 is een framework voor het ontwikkelen van VR en 360\textdegree applicaties in javascript door facebook. React 360 wordt gebruikt om gemakkelijk een complexe gebruikersomgeving te kunnen maken in een 360\textdegree omgeving. Het grote voordeel aan React 360 is dat het gewoon in de browser kan worden uitgevoerd. Dit wil dus zeggen dat, gebruikers met een recente versie van hun browser, React 360 applicaties zonder problemen kunnen uitvoeren. Daarnaast is React 360 op meerdere platformen beschikbaar en is er ook geen verplichting om een VR headset te gebruiken. Men kan React 360 gaan ervaren op zowel pc, smartphone als op andere VR apparaten.

In React 360 gaat men eigenlijk 2D met 3D gaan combineren. Men gaat 2D interfaces in een 3D omgeving gaan plaatsen maar er is ook de mogelijkheid om gebruik te maken van 3D objecten die in de wereld kunnen geplaatst worden. Enkele voorbeelden waar React 360 kan gebruikt voor worden is foto's, videos, 360\textdegree rondleidingen en zelfs simpele games.

Waarschijnljk het grootste voordeel aan React 360 is dat het al gebruik maakt van het bestaande React JS. Voor mensen die dit framework al kennen, dat trouwens ook ontwikkeld is door facebook, is de overstap naar het ontwikkelen van VR applicaties dus een pak eenvoudiger. Bepaalde concepten van React Native komen ook terug in React 360. React Native is ook een framework door facebook dat ook gebasseerd is op React JS. Met React Native kunnen mobiele applicaties worden ontwikkeld voor zowel iOS als voor Android.

\section{React.js}
\label{sec:reactjs}
Reat JS is een framework dat gemaakt is om user interfaces, gebruikersomgevingen, te gaan ontwikkelen. Hiermee kan er zeer gemakkelijk een complexe user interface worden gebouwd waarbij alle data op de juiste manier wordt aangepast door het framework. Het is belangrijk dat we bekijken wat de belangrijkste onderdelen zijn van het React JS framework voor we verder kunnen gaan op React 360. React 360 is immers gebouwd op React JS.

\subsection{JSX}
\label{subsec:jsx}
JSX is een uitbreiding op javascript. JSX is eigenlijk iets dat hetzelfde doet als wat een HTML tag doet, maar is eigenlijk een samenvoeging van HTML en javascript. Dit is hoe een JSX tag er uit ziet: 

\begin{lstlisting}[frame=single, caption=Voorbeeld van een JSX tag]
const element = <h1>Hello, world!</h1>;
\end{lstlisting}

Je kan dus gewoon HTML gaan gebruiken in je javascript code. Dit maakt het een pak gemakkelijker om interfaces te gaan bouwen. In het voorbeeld hebben we de html tag \lstinline[basicstyle=\ttfamily\color{red}]|<h1>| met bijhorende tekst in een variabele gestopt, wat natuurlijk niet mogelijk is in een gewoon .html bestand of in een gewoon javascript bestand zonder JSX. Daarnaast verhoogt JSX de leesbaarheid van de code en is het niet moeilijk om aan te leren als men al HTML en javascript kent.

\subsection{Components en props}
\label{subsec:components-en-props}
React is opgebouwd uit components die onafhankelijk en herbruikbaar zijn. Met deze components kan dus een user interface worden opgebouwd. Deze components bestaan dan op zichzelf uit een verzameling van JSX tags.

Een user interface is meestal een soort van boom die opgebouwd is uit andere kleine onderdelen. Hier schijnt React dus in uit, je kan dus aan deze componenten, sub-componenten gaan toevoegen en zo een duidelijke opbouw en structuur hebben.

\begin{figure}
	\centering
	\includegraphics[width=0.4\linewidth]{ThinkingInReact.png}
	\caption{De opbouw van componenten en sub-componenten.}
	\label{fig:ar-vs-vr}
\end{figure}

In het voorbeeld zien we dus hoe een component kan opgebouwd uit meerdere sub-componenten en dat deze ook kunnen hergebruikt worden. Dit zorgt voor minder duplicate en meer consistente code. Een component gaan definiëren in React gaat als volgt:

\begin{lstlisting}[frame=single, caption=Het component HelloWorld wordt gedefinieerd]
class HelloWorld extends React.Component {
	render() {
		return <h1>Hello world!</h1>
	}
}
\end{lstlisting}

Een component moet altijd iets kunnen tonen. Het is dus verplicht om de \lstinline[basicstyle=\ttfamily\color{red}]|render()| functie te initialiseren. Deze render functie zal dan JSX teruggeven.

Het is ook mogelijk om net zoals bij een gewoon HTML element, attributen of in React, props mee te geven aan een component. Met deze props is het mogelijk om ervoor te zorgen dat componenten dynamisch zijn en dus niet enkel hetzelfde moeten teruggeven. De props van een component kan je aanspreken door \lstinline[basicstyle=\ttfamily\color{red}]|this.props| te gaan gebruiken. In dit voorbeeld maken we een component die gebruik maakt van de property name:

\begin{lstlisting}[frame=single, caption=Het component Hello wordt gedefinieerd die de property 'name' gebruikt]
class Hello extends React.Component {
	render() {
		return <h1>Hello {this.props.name}!</h1>
	}
}
\end{lstlisting}

Om dan de property te kunnen gebruiken kunnen we dit net zoals bij een gewone HTML tag in het element van het component gaan zetten:

\begin{lstlisting}[frame=single, caption=Het component Hello met de property name]
<Hello name='Arne'/>
\end{lstlisting}

Op de webpagina zouden we dan het resultaat \lstinline[basicstyle=\ttfamily\color{red}]|Hello Arne!| terugkrijgen. Hier tonen we dus ook de herbruikbaarheid aan, als we dit meerdere malen met andere namen zouden willen doen kunnen we simpelweg de prop name aanpassen zonder dat we een volledig nieuw component zouden moeten definiëren:

\begin{lstlisting}[frame=single, caption=Het component Hello die meerdere malen met andere props wordt gebruikt.]
<Hello name='Arne'/>
<Hello name='Thibault'/>
<Hello name='Sebastiaan'/>
\end{lstlisting}


\subsection{State en levenscyclus}
\label{subsec:state-en-levenscyclus}
We hebben dus al een manier om componenten dynamisch te gaan opbouwen met andere data. Maar wat als we nu een component \lstinline[basicstyle=\ttfamily\color{red}]|Temperature| zouden hebben die het aantal graden teruggeeft. We kunnen props niet meer aanpassen achteraf dus dan zouden we steeds een nieuw component moeten gaan aanmaken wat natuurlijk niet echt handig is. Hiervoor biedt het state object van een component de oplossing. Een state is eigenlijk data die in het component zit en naargelang de levenscyclus van een component kan veranderen. Zo is het dus mogelijk om het aantal graden van het temperatuur component te gaan aanpassen elke keer dat deze wijzigt. Zo zou het temperatuur component er dus uitzien:

\begin{lstlisting}[frame=single, caption=Het temperature component met de bijhorende state.]
class Temperature extends React.Component {
	constructor() {
		super()
		this.state = {
			degree: 0;
		}
	}
	
	setTemperature(amountCelsius) {
		this.setState({
			degree: amountCelsius;
		})
	}

	render() {
		return <p>{this.state.degree}</p>
	}
}
\end{lstlisting}

We zien dus dat het temperatuur component een \lstinline[basicstyle=\ttfamily\color{red}]|constructor()| functie bevat. Dit is een speciale methode die gebruikt wordt om objecten te gaan maken voor de componenten \autocite{Chima2017}. In dit geval gaan we dus het state object gaan aanmaken met de eigenschap \lstinline[basicstyle=\ttfamily\color{red}]|degree| die de initiële waarde 0 bevat. We zien ook de functie eigenschap \lstinline[basicstyle=\ttfamily\color{red}]|setTemperature(amountCelsius)|. Deze functie heeft een parameter en bevat de een call naar de functie \lstinline[basicstyle=\ttfamily\color{red}]|setState()| waarmee de waarde van de state eigenschappen kan worden aangepast. Stel dat deze functie wordt opgeroepen elke keer da de temperatuur zou wijzigen zal hij deze kunnen doorgeven door middel van de parameter \lstinline[basicstyle=\ttfamily\color{red}]|amountCelsius|. Ten slotte wordt dan de render methode gebruikt om de eigenschap \lstinline[basicstyle=\ttfamily\color{red}]|degree|
van het state object te kunnen tonen.

Elke component heeft een zogenaamde levenscyclus. Deze cyclus start dus vanaf de component bestaat tot dat het verdwijnt. Tijdens de levenscyclus worden er automatisch een aantal methodes opgeroepen, de 'lifecycle hooks'. Enkele voorbeelden van deze hooks zijn de \lstinline[basicstyle=\ttfamily\color{red}]|componentDidMount| en \lstinline[basicstyle=\ttfamily\color{red}]|componentWillUnmount|. De \lstinline[basicstyle=\ttfamily\color{red}]|componentDidMount| wordt opgeroepen als de \lstinline[basicstyle=\ttfamily\color{red}]|render()| methode is uitgevoerd. De \lstinline[basicstyle=\ttfamily\color{red}]|componentWillUnmount| wordt uitgevoerd als de component gaat verdwijnen van de pagina.

\subsection{Events}
\label{subsec:events}
In React gaat het verwerken van events, interacties van de gebruiker, zeer makkelijk. Bij een element kan je een onClick gaan toevoegen die dan verwijst naar de methode die het event afhandelt. Daarnaast kan je eventueel ook parameters meegeven aan deze methode. Hier zien we in een kort voorbeeld duidelijk de werking ervan:

\begin{lstlisting}[frame=single, caption=Voorbeeld van een vent afhandelen.]
class Leeftijd extends React.Component {
	contructor() {
		super();
		this.state = {
			leeftijd: 0
		};
		
		this.handleClick = this.handleClick.bind(this);
	}
	
	handleClick() {
		this.setState({
			leeftijd: this.state.leeftijd + 1
		});
	}

	render() {
		return <button onClick={this.handleClick}>Verhoog leeftijd</button>
	}
}
\end{lstlisting}

Bij dit voorbeeld hebben we de een button gedefenieerd met de toegevoegde prop \lstinline[basicstyle=\ttfamily\color{red}]|onClick|. Hierbij verwijzen we dan naar de methode handleClick. Omdat in javascript de methodes nog niet standaard 'gebind' zijn aan een klasse. Is het belangrijk dat we dit nog doen zodat we correct naar de methode handleClick kunnen verwijzen. Anders zal dit een undefined teruggeven.

\section{Werking van React 360}
\label{sec:werking-react360}

\section{Enkele belangrijke componenten}
\label{sec:reactvr-componenten}

\subsection{View}
\label{subsec:view}
De view is het fundamentele component om in React 306 een user interface te kunnen bouwen. De view is een container die ervoor zorgt dat je elementen kan gaan tonen, stijl kan geven, elementen sorteren en groeperen en om interacties op uit te voeren. Een view vergelijkbaar met een \lstinline[basicstyle=\ttfamily\color{red}]|<div>| element van html maar dan geoptimaliseerd voor React 360. Een view kan als volgt worden gebruikt:

\begin{lstlisting}[frame=single, caption=Een component die een View teruggeeft.]
class BasicView extends React.Component {
	render() {
		return (
			<View style={{backgroundColor: 'blue', height: 150px}}>
				<View style={{backgroundColor: 'red', height: 100px}}+>
			</View>
		);
	}
}
\end{lstlisting}

Hier maken we een simpel component aan die een view retourneert waarbij de achtergrond blauw is en de hoogte 150 pixels. In deze view zit dan een ander view met een rode achtergrond.

\subsection{Text}
\label{subsec:text}
Het Text component is zoals de naam zegt om text te gaan teruggeven in React 360. Dit is vergelijkbaar met het \lstinline[basicstyle=\ttfamily\color{red}]|<p>| element van html. Net zoals bij een View kan je hier ook stijl op toepassen, maar dan voor de tekst.

\begin{lstlisting}[frame=single, caption=Het Text component met kinderen.]
<Text>
	<Text>Dit is</Text>
	<Text>een stukje tekst</Text>
</Text>
\end{lstlisting}

\subsection{Image}
\label{subsec:image}
Het Image component zegt ook zeer duidelijk wat het doet. Het geeft simpelweg een afbeelding terug en is dus vergelijkbaar met het \lstinline[basicstyle=\ttfamily\color{red}]|<img>| element van html. Het is gebruikelijk om deze images op te slaan in de 'static_assets' folder die wordt gegenereerd bij het aanmaken van een React 360 project. In volgend voorbeeld gaan we dus een Image gaan definiëren die zich in de static\_assets folder bevindt met de naam een-afbeelding.jpg:

\begin{lstlisting}[frame=single, caption=Het Image component met als bron een-afbeelding.jpg.]
<View>
	<Image source={asset('een-afbeelding.jpg')} />
</View>
\end{lstlisting}

\section{Concepten}

\subsection{360\textdegree foto's en video's}
\label{subsec:360-photo-video}
Waar React 360 zeer goed in is, is het tonen van 360\textdegree foto's en videos. Deze zijn natuurlijk essentieel voor een een realistische omgeving te kunnen creëren. Met deze foto's en video's kunnen we dus mensen naar andere bestaande plaatsen in de wereld gaan transporteren en dit in combinatie met een interactieve ervaring. Denk maar aan een tour in een museum waarbij de gebruiker naar de verschillende ruimtes kan teleporteren.

React 360 biedt een aantal vormen van formaten aan voor zowel foto's en videos te tonen in 180\textdegree of 360\textdegree:

\subsubsection{Foto's}
\begin{itemize}
	\item 360\textdegree mono equirectangular
	\item 360\textdegree stereo equirectangular (boven/onder)
	\item 180\textdegree mono equirectangular
	\item 180\textdegree stereo equirectangular (boven/onder)
	\item 180\textdegree stereo equirectangular (links/rechts)
\end{itemize}

\subsubsection{Video's}
\begin{itemize}
	\item 360\textdegree mono equirectangular
	\item 360\textdegree stereo equirectangular (boven/onder)
	\item 180\textdegree mono equirectangular
	\item 180\textdegree stereo equirectangular (links/rechts)
\end{itemize}

Een equirectangular of in het nederlands equidistante cilinderprojectie is een projectie van een gebogen oppervlak op een vlak oppervlak. Deze techniek wordt vooral gebruikt bij de wereldkaart, maar dus ook in de wereld van VR. 

\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{equirectangular.png}
	\caption{Een equidistante cilinderprojectie.}
	\label{fig:eq-cilinder}
\end{figure}

Het verschil tussen een mono en stereo afbeelding is zoals er in hoofdstuk \ref{subsec:stereoscopie} werd gesproken over stereoscopie. Bij mono gaat men dus maar 1 afbeelding gaan tonen vanaf 1 perspectief terwijl men bij stereo 2 afbeelding vanaf een verschillend perspectief gaat tonen om dieptezicht mogelijk te maken. Bij React 360 is dit mogelijk door de afbeelding voor het linkse oog vanboven (of links bij 180°) te zetten en de afbeelding voor het rechtse oog aan de onderkant (of rechts bij 180°) te zetten en dit dan in 1 afbeelding te plaatsen. Het is natuurlijk enkel mogelijk om stereoafbeeldingen te bekijken met een 3D headset. Indien de gebruiker dus de applicatie zou uitvoeren zonder een VR headset dan kan men enkel hetgeen zien wat men in het linkse oog zou zien.

\subsubsection{Panorama foto's video's tonen}
Je kan foto's of video's zowel in de runtime (\ref{sec:werking-react360}) als in de React zelf gaan tonen. Dit kan je voor afbeeldingen doen in de runtime met volgende code:

\begin{lstlisting}[frame=single, caption=Een afbeelding als achtergrond instellen in de runtime.]
r360.compositor.setBackground('./static_assets/image.jpg', {
	format: '2D',
});
\end{lstlisting}

Zoals je kan zien is dit zeer gemakkelijk en vanzelfsprekend, maar is er wel een extra argument nodig namelijk het formaat. Er zijn 4 mogelijke formaten die je kan opgeven als argument in de code die overeenstemmen met de eerder genoemde formaten:

\begin{itemize}
	\item \textbf{2D} voor mono afbeeldingen/video's 
	\item \textbf{3DTB} voor stereo afbeelding/video's waarbij de afbeelding voor het links oog vanboven staat en de afbeelding voor het rechtse oog vanonder.
	\item \textbf{3DBT} voor stereo afbeelding/video's waarbij de afbeelding voor het rechtse oog vanboven staat en de afbeelding voor het linkse oog vanonder.
	\item \textbf{3DLR} voor stereo afbeelding/video's waarbij de afbeelding voor het links oog links staat en de afbeelding voor het rechtse oog rechts.
\end{itemize}

Om video's af te spelen volgen we een gelijkaardig proces. Hier heb je dus ook de keuze om die in de runtime of in React te gaan doen. Het grote verschil dan bij een afbeelding is dat je hier in 2 delen zal gaan werken. Eerst ga je de videospeler gaan aanmaken die een unieke naam moet krijgen en dan ga je deze videospeler gaan instellen als achtergrond.


\subsection{Het ruimtelijke systeem}
\label{subsec:ruimtelijk-systeem}
Het grootste verschil met een gewone webapplicatie en een VR applicatie is dat deze VR applicaties zich in een 3D ruimte bevinden. Er moet dus niet enkel worden rekening gehouden met hoogte en breedte maar dus ook met diepte. Dit kan al vrij snel ingewikkeld worden maar React 360 heeft ervoor gezorgd dat dit een pak makkelijker gaat

\subsubsection{Surfaces}
\label{ssubsec:surfaces}
Surfaces (oppervlaktes) bieden de mogelijkheid om 2D user interfaces in een 3D wereld te gaan stoppen. Je kan het gaan vergelijken met een stuk van een webpagina in een 3D wereld te gaan stoppen. Dit zorgt ervoor dat het dus een pak makkelijk is voor een ontwikkelaar om een ingewikkelde interface in React 360 te kunnen maken. In de code ziet een surface er zo uit:

\begin{lstlisting}[frame=single, caption=Voorbeeld van een surface]
import {Surface} from 'react-360-web';

const eenSurface = new Surface(
		500,
		400,
		Surface.SurfaceShape.Cylinder
	);
\end{lstlisting}

Er wordt dus een breedte (500) en een hoogte (400) voor de surface gedifinieerd. Daarnaast wordt er ook nog een vorm toegevoegd als argument. Je hebt 2 vormen van een surface, namelijk een 'Cylinder' of 'Flat' surface. Bij een cylinder surface gaat men dus de 2D inhoud gaan projecten in de vorm van een cylinder, rondom de gebruiker. Het grote voordeel hieraan is is dat je vanaf elk perspectief je recht op de 2D interface gaat kijken. Bij een flat of vlakke surface gaat men de 2D interface dan zoals de naam zegt, vlak gaan plaatsen. Het grote verschil is dus dat de inhoud niet altijd van hetzelfde perspectief wordt bekeken.

Surface zijn zeer flexibel. Je kan ze gemakkelijk gaan bewerken door functies zoals \lstinline[basicstyle=\ttfamily\color{red}]|setShape| te gaan gebruiken waarbij je de surface van een cylinder naar een vlakke surface kan aanpassen of omgekerd. Ook de hoogte en breedte van surfaces kan je perfect in React aanpassen. Het is dus ook perfect mogelijk om meerdere surfaces naast mekaar te gaan gebruiken of om eventueel ook meerdere componenten in 1 surface te gaan stoppen. 

Aangezien er meerdere componenten kunnen worden gestopt in 1 surface is er ook nood aan een duidelijke manier om deze componenten te ordenen. Dit is net hetzelfde als dat bij React Native wordt gebruikt namelijk flexbox. Flexbox wordt ook al veel gebruikt in gewone webpagina's en zorgt vooral voor een consistente layout op alle schermgroottes.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\linewidth]{flexbox.png}
	\caption{Een flexbox container met flex items.}
	\label{fig:flexbox}
\end{figure}

\subsubsection{3D-objecten}
\label{ssubsec:3d-objecten}
Het is ook mogelijk om 3D objecten te gaan gebruiken in React 360. Dit zijn objecten die op voorhand al gemaakt zijn in een ander programma van het formaat .obj, .mtl of .gltf2.

Het verschil met 3D objecten en 2D user interfaces is dat deze niet aan een surface moeten worden toegevoegd maar aan een 'Location'. Deze locations zijn eigenlijk gewoonweg punten in de omgeving waar je de 3D objecten kan gaan plaatsen. Deze gaan declareren in de code lijkt ook  veel op het declareren van een surface, enkel hier is er ook nood aan de X, Y en Z coördinaten. Waarbij X+ dus hetgeen rechts van de gebruiker voorstelt, Y+ de hoogte en Z+ hetgeen achter de gebruiker. De eenheid die hier gebruikt wordt is meter.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\linewidth]{3daxis.png}
	\caption{De X, Y en Z assen.}
	\label{fig:xyz-axis}
\end{figure}

\begin{lstlisting}[frame=single, caption=Voorbeeld van een surface]
mport {Location} from 'react-360-web';

const location = new Location([0, -1, -2]);
\end{lstlisting}

Om 3D objecten van de opgenoemde formaten in onze applicatie te krijgen moeten we gebruik maken an het Entity component. Met dit component kunnen we dan ook de grootte en richting van dit 3D object gaan aanpassen. Dit gebeurt door \lstinline[basicstyle=\ttfamily\color{red}]|translate| of \lstinline[basicstyle=\ttfamily\color{red}]|rotateX|/\lstinline[basicstyle=\ttfamily\color{red}]|rotateY|\lstinline[basicstyle=\ttfamily\color{red}]|rotateZ| toe te voegen aan het entity component. Bij rotate worden dan de graden opgegeven en bij translate de coordinaten ten opzichte van de gebruiker. Dit is heel gemakkelijk om in code te gaan gebruiken:

\begin{lstlisting}[frame=single, caption=Voorbeeld van een Entity component]
<Entity 
	style={{transform: [
		{translate: [0, 0, -1]},
		{rotateY: 90}
		]}}>
	source={{obj: asset('een3DObject.obj')}}
/>
\end{lstlisting}

Hierbij draaien we dus het 3D object met 90 graden volgens de Y as en verplaatsen we het -1 meter volgens de Z as. Nu zal het object dus voor ons tevoorschijn komen.

\subsection{Geluid}
\label{subsec:Geluid}
Net zoals het mogelijk is om afbeeldingen en video's op de achtergrond te gebruiken is het ook perfect mogelijk om de applicatie van achtergrond geluid te voorzien. 


\subsection{Input in VR}
\label{subsec:input-vr}


\subsection{Native Modules}

\section{Prestaties}
\label{sec:prestaties}