%%=============================================================================
%% React VR
%%=============================================================================
\chapter{React 360}
\label{ch:react-360}

React 360 is een framework voor het ontwikkelen van VR en 360\textdegree applicaties in javascript door facebook. React 360 wordt gebruikt om gemakkelijk een complexe gebruikersomgeving te kunnen maken in een 360\textdegree omgeving. Het grote voordeel aan React 360 is dat het gewoon in de browser kan worden uitgevoerd. Dit wil dus zeggen dat, gebruikers met een recente versie van hun browser, React 360 applicaties zonder problemen kunnen uitvoeren. Daarnaast is React 360 op meerdere platformen beschikbaar en is er ook geen verplichting om een VR headset te gebruiken. Men kan React 360 gaan ervaren op zowel pc, smartphone als op andere VR apparaten.

In React 360 gaat men eigenlijk 2D met 3D gaan combineren. Men gaat 2D interfaces in een 3D omgeving gaan plaatsen maar er is ook de mogelijkheid om gebruik te maken van 3D objecten die in de wereld kunnen geplaatst worden. Enkele voorbeelden waar React 360 kan gebruikt voor worden is foto's, videos, 360\textdegree rondleidingen en zelfs simpele games.

Waarschijnljk het grootste voordeel aan React 360 is dat het al gebruik maakt van het bestaande React JS. Voor mensen die dit framework al kennen, dat trouwens ook ontwikkeld is door facebook, is de overstap naar het ontwikkelen van VR applicaties dus een pak eenvoudiger. Bepaalde concepten van React Native komen ook terug in React 360. React Native is ook een framework door facebook dat ook gebasseerd is op React JS. Met React Native kunnen mobiele applicaties worden ontwikkeld voor zowel iOS als voor Android.

\section{React.js}
\label{sec:reactjs}
Reat JS is een framework dat gemaakt is om user interfaces, gebruikersomgevingen, te gaan ontwikkelen. Hiermee kan er zeer gemakkelijk een complexe user interface worden gebouwd waarbij alle data op de juiste manier wordt aangepast door het framework. Het is belangrijk dat we bekijken wat de belangrijkste onderdelen zijn van het React JS framework voor we verder kunnen gaan op React 360. React 360 is immers gebouwd op React JS.

\subsection{JSX}
\label{subsec:jsx}
JSX is een uitbreiding op javascript. JSX is eigenlijk iets dat hetzelfde doet als wat een HTML tag doet, maar is eigenlijk een samenvoeging van HTML en javascript. Dit is hoe een JSX tag er uit ziet: 

\begin{lstlisting}[frame=single, caption=Voorbeeld van een JSX tag]
const element = <h1>Hello, world!</h1>;
\end{lstlisting}

Je kan dus gewoon HTML gaan gebruiken in je javascript code. Dit maakt het een pak gemakkelijker om interfaces te gaan bouwen. In het voorbeeld hebben we de html tag \lstinline[basicstyle=\ttfamily\color{red}]|<h1>| met bijhorende tekst in een variabele gestopt, wat natuurlijk niet mogelijk is in een gewoon .html bestand of in een gewoon javascript bestand zonder JSX. Daarnaast verhoogt JSX de leesbaarheid van de code en is het niet moeilijk om aan te leren als men al HTML en javascript kent.

\subsection{Components en props}
\label{subsec:components-en-props}
React is opgebouwd uit components die onafhankelijk en herbruikbaar zijn. Met deze components kan dus een user interface worden opgebouwd. Deze components bestaan dan op zichzelf uit een verzameling van JSX tags.

Een user interface is meestal een soort van boom die opgebouwd is uit andere kleine onderdelen. Hier schijnt React dus in uit, je kan dus aan deze componenten, sub-componenten gaan toevoegen en zo een duidelijke opbouw en structuur hebben.

\begin{figure}
	\centering
	\includegraphics[width=0.4\linewidth]{ThinkingInReact.png}
	\caption{De opbouw van componenten en sub-componenten.}
	\label{fig:ar-vs-vr}
\end{figure}

In het voorbeeld zien we dus hoe een component kan opgebouwd uit meerdere sub-componenten en dat deze ook kunnen hergebruikt worden. Dit zorgt voor minder duplicate en meer consistente code. Een component gaan definiëren in React gaat als volgt:

\begin{lstlisting}[frame=single, caption=Het component HelloWorld wordt gedefinieerd]
class HelloWorld extends React.Component {
	render() {
		return <h1>Hello world!</h1>
	}
}
\end{lstlisting}

Een component moet altijd iets kunnen tonen. Het is dus verplicht om de \lstinline[basicstyle=\ttfamily\color{red}]|render()| functie te initialiseren. Deze render functie zal dan JSX teruggeven.

Het is ook mogelijk om net zoals bij een gewoon HTML element, attributen of in React, props mee te geven aan een component. Met deze props is het mogelijk om ervoor te zorgen dat componenten dynamisch zijn en dus niet enkel hetzelfde moeten teruggeven. De props van een component kan je aanspreken door \lstinline[basicstyle=\ttfamily\color{red}]|this.props| te gaan gebruiken. In dit voorbeeld maken we een component die gebruik maakt van de property name:

\begin{lstlisting}[frame=single, caption=Het component Hello wordt gedefinieerd die de property 'name' gebruikt]
class Hello extends React.Component {
	render() {
		return <h1>Hello {this.props.name}!</h1>
	}
}
\end{lstlisting}

Om dan de property te kunnen gebruiken kunnen we dit net zoals bij een gewone HTML tag in het element van het component gaan zetten:

\begin{lstlisting}[frame=single, caption=Het component Hello met de property name]
<Hello name='Arne'/>
\end{lstlisting}

Op de webpagina zouden we dan het resultaat \lstinline[basicstyle=\ttfamily\color{red}]|Hello Arne!| terugkrijgen. Hier tonen we dus ook de herbruikbaarheid aan, als we dit meerdere malen met andere namen zouden willen doen kunnen we simpelweg de prop name aanpassen zonder dat we een volledig nieuw component zouden moeten definiëren:

\begin{lstlisting}[frame=single, caption=Het component Hello die meerdere malen met andere props wordt gebruikt.]
<Hello name='Arne'/>
<Hello name='Thibault'/>
<Hello name='Sebastiaan'/>
\end{lstlisting}


\subsection{State en levenscyclus}
\label{subsec:state-en-levenscyclus}
We hebben dus al een manier om componenten dynamisch te gaan opbouwen met andere data. Maar wat als we nu een component \lstinline[basicstyle=\ttfamily\color{red}]|Temperature| zouden hebben die het aantal graden teruggeeft. We kunnen props niet meer aanpassen achteraf dus dan zouden we steeds een nieuw component moeten gaan aanmaken wat natuurlijk niet echt handig is. Hiervoor biedt het state object van een component de oplossing. Een state is eigenlijk data die in het component zit en naargelang de levenscyclus van een component kan veranderen. Zo is het dus mogelijk om het aantal graden van het temperatuur component te gaan aanpassen elke keer dat deze wijzigt. Zo zou het temperatuur component er dus uitzien:

\begin{lstlisting}[frame=single, caption=Het temperature component met de bijhorende state.]
class Temperature extends React.Component {
	constructor() {
		super()
		this.state = {
			degree: 0;
		}
	}
	
	setTemperature(amountCelsius) {
		this.setState({
			degree: amountCelsius;
		})
	}

	render() {
		return <p>{this.state.degree}</p>
	}
}
\end{lstlisting}

We zien dus dat het temperatuur component een \lstinline[basicstyle=\ttfamily\color{red}]|constructor()| functie bevat. Dit is een speciale methode die gebruikt wordt om objecten te gaan maken voor de componenten \autocite{Chima2017}. In dit geval gaan we dus het state object gaan aanmaken met de eigenschap \lstinline[basicstyle=\ttfamily\color{red}]|degree| die de initiële waarde 0 bevat. We zien ook de functie eigenschap \lstinline[basicstyle=\ttfamily\color{red}]|setTemperature(amountCelsius)|. Deze functie heeft een parameter en bevat de een call naar de functie \lstinline[basicstyle=\ttfamily\color{red}]|setState()| waarmee de waarde van de state eigenschappen kan worden aangepast. Stel dat deze functie wordt opgeroepen elke keer da de temperatuur zou wijzigen zal hij deze kunnen doorgeven door middel van de parameter \lstinline[basicstyle=\ttfamily\color{red}]|amountCelsius|. Ten slotte wordt dan de render methode gebruikt om de eigenschap \lstinline[basicstyle=\ttfamily\color{red}]|degree|
van het state object te kunnen tonen.

Elke component heeft een zogenaamde levenscyclus. Deze cyclus start dus vanaf de component bestaat tot dat het verdwijnt. Tijdens de levenscyclus worden er automatisch een aantal methodes opgeroepen, de 'lifecycle hooks'. Enkele voorbeelden van deze hooks zijn de \lstinline[basicstyle=\ttfamily\color{red}]|componentDidMount| en \lstinline[basicstyle=\ttfamily\color{red}]|componentWillUnmount|. De \lstinline[basicstyle=\ttfamily\color{red}]|componentDidMount| wordt opgeroepen als de \lstinline[basicstyle=\ttfamily\color{red}]|render()| methode is uitgevoerd. De \lstinline[basicstyle=\ttfamily\color{red}]|componentWillUnmount| wordt uitgevoerd als de component gaat verdwijnen van de pagina.

\subsection{Events}
\label{subsec:events}
In React gaat het verwerken van events, interacties van de gebruiker, zeer makkelijk. Bij een element kan je een onClick gaan toevoegen die dan verwijst naar de methode die het event afhandelt. Daarnaast kan je eventueel ook parameters meegeven aan deze methode. Hier zien we in een kort voorbeeld duidelijk de werking ervan:

\begin{lstlisting}[frame=single, caption=Voorbeeld van een vent afhandelen.]
class Leeftijd extends React.Component {
	contructor() {
		super();
		this.state = {
			leeftijd: 0
		};
		
		this.handleClick = this.handleClick.bind(this);
	}
	
	handleClick() {
		this.setState({
			leeftijd: this.state.leeftijd + 1
		});
	}

	render() {
		return <button onClick={this.handleClick}>Verhoog leeftijd</button>
	}
}
\end{lstlisting}

Bij dit voorbeeld hebben we de een button gedefenieerd met de toegevoegde prop \lstinline[basicstyle=\ttfamily\color{red}]|onClick|. Hierbij verwijzen we dan naar de methode handleClick. Omdat in javascript de methodes nog niet standaard 'gebind' zijn aan een klasse. Is het belangrijk dat we dit nog doen zodat we correct naar de methode handleClick kunnen verwijzen. Anders zal dit een undefined teruggeven.

\section{Werking van React 360}
\label{sec:werking-react360}


React 360 is een framework waarmee we op een eenvoudige manier VR applicaties kunnen gaan maken. Deze VR applicaties spelen zich af in een 3D omgeving. Het is natuurlijk niet zomaar dat React 360 het mogelijk maakt om met gewone React JS code componenten toe te voegen aan deze 3D omgeving. Hiervoor heeft het framework een uitgebreide 'stack' van software libraries om dit mogelijk te maken \autocite{Bieronski2016}.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.4\linewidth]{react360stack.png}
	\caption{De software stack van React 360 (React VR).}
	\label{fig:react360-stack}
\end{figure}

Een React 360 applicatie bestaat uit 2 delen, waaronder de applicatie zelf (de code die je dus schrijft) en de 1ste laag op de afbeelding namelijk de React Runtime. Dit zorgt ervoor dat onze code geconverteerd wordt naar code die de andere lagen snappen. Daarnaast zorgt het ervoor dat de browser niet vastloopt omdat de code apart wordt uitgevoerd en dan pas aan de 3D omgeving wordt toegevoegd waardoor de beelden per seconde dus consistent blijven en zo het gevoel van onderdompeling in de virtuele wereld niet verdwijnt. Ten slotte bevat deze runtime nog zogenaamde 'Executors'. Deze executors zorgen ervoor dat er nog code in de achtergrond kan worden uitgevoerd, dus niet noodzakelijk in de browser zelf.

Op de 2de laag hebben we OVRUI (Oculus VR User Interface) en Three.js. De OVRUI is een library die ervoor zorgt dat bepaalde elementen gemakkelijk kunnen weergegeven worden via Three.js. Dit zijn onder andere text, knoppen, ... Three.js is dan weer een library die het mogelijk maakt om 3D objecten te kunnen weergeven in de browser.

De laatste laag bestaat dan uit WebVR en de browser. WebVR is hetgeen wat ervoor zorgt dat een virtual reality experience mogelijk is in de browser en hangt nauw samen met WebGL (waar Three.js ook gebruik van maakt). Dat is een standaard voor 3D objecten in de browser te verkrijgen. Zo kan het herkennen welk type toestel je gebruikt, zorgt het voor de communicatie met VR toestellen en toont het de 'VR Frame', het stuk op de webpagina dat dus in VR moet worden weergegeven. 

We zien dus dat React 360 een verzameling is van meerdere technologieën waar men dan a.d.h.v. React JS gemakkelijk mee kan communiceren. Dit toont dus duidelijk aan dat React 360 het voor een ontwikkelaar veel eenvoudiger maakt om virtual reality applicaties te gaan maken.

\section{Enkele belangrijke componenten}
\label{sec:reactvr-componenten}
React 360 heeft nog enkele belangrijke componenten die niet beschikbaar zijn in de gewone React JS.

\subsection{View}
\label{subsec:view}
De view is het fundamentele component om in React 306 een user interface te kunnen bouwen. De view is een container die ervoor zorgt dat je elementen kan gaan tonen, stijl kan geven, elementen sorteren en groeperen en om interacties op uit te voeren. Een view vergelijkbaar met een \lstinline[basicstyle=\ttfamily\color{red}]|<div>| element van html maar dan geoptimaliseerd voor React 360. Een view kan als volgt worden gebruikt:

\begin{lstlisting}[frame=single, caption=Een component die een View teruggeeft.]
class BasicView extends React.Component {
	render() {
		return (
			<View style={{backgroundColor: 'blue', height: 150px}}>
				<View style={{backgroundColor: 'red', height: 100px}}+>
			</View>
		);
	}
}
\end{lstlisting}

Hier maken we een simpel component aan die een view retourneert waarbij de achtergrond blauw is en de hoogte 150 pixels. In deze view zit dan een ander view met een rode achtergrond.

\subsection{Text}
\label{subsec:text}
Het Text component is zoals de naam zegt om text te gaan teruggeven in React 360. Dit is vergelijkbaar met het \lstinline[basicstyle=\ttfamily\color{red}]|<p>| element van html. Net zoals bij een View kan je hier ook stijl op toepassen, maar dan voor de tekst.

\begin{lstlisting}[frame=single, caption=Het Text component met kinderen.]
<Text>
	<Text>Dit is</Text>
	<Text>een stukje tekst</Text>
</Text>
\end{lstlisting}

\subsection{Image}
\label{subsec:image}
Het Image component zegt ook zeer duidelijk wat het doet. Het geeft simpelweg een afbeelding terug en is dus vergelijkbaar met het \lstinline[basicstyle=\ttfamily\color{red}]|<img>| element van html. Het is gebruikelijk om deze images op te slaan in de 'static_assets' folder die wordt gegenereerd bij het aanmaken van een React 360 project. In volgend voorbeeld gaan we dus een Image gaan definiëren die zich in de static\_assets folder bevindt met de naam een-afbeelding.jpg:

\begin{lstlisting}[frame=single, caption=Het Image component met als bron een-afbeelding.jpg.]
<View>
	<Image source={asset('een-afbeelding.jpg')} />
</View>
\end{lstlisting}

\section{Concepten}

\subsection{360\textdegree foto's en video's}
\label{subsec:360-photo-video}
Waar React 360 zeer goed in is, is het tonen van 360\textdegree foto's en videos. Deze zijn natuurlijk essentieel voor een een realistische omgeving te kunnen creëren. Met deze foto's en video's kunnen we dus mensen naar andere bestaande plaatsen in de wereld gaan transporteren en dit in combinatie met een interactieve ervaring. Denk maar aan een tour in een museum waarbij de gebruiker naar de verschillende ruimtes kan teleporteren.

React 360 biedt een aantal vormen van formaten aan voor zowel foto's en videos te tonen in 180\textdegree of 360\textdegree:

\subsubsection{Foto's}
\begin{itemize}
	\item 360\textdegree mono equirectangular
	\item 360\textdegree stereo equirectangular (boven/onder)
	\item 180\textdegree mono equirectangular
	\item 180\textdegree stereo equirectangular (boven/onder)
	\item 180\textdegree stereo equirectangular (links/rechts)
\end{itemize}

\subsubsection{Video's}
\begin{itemize}
	\item 360\textdegree mono equirectangular
	\item 360\textdegree stereo equirectangular (boven/onder)
	\item 180\textdegree mono equirectangular
	\item 180\textdegree stereo equirectangular (links/rechts)
\end{itemize}

Een equirectangular of in het nederlands equidistante cilinderprojectie is een projectie van een gebogen oppervlak op een vlak oppervlak. Deze techniek wordt vooral gebruikt bij de wereldkaart, maar dus ook in de wereld van VR. 

\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{equirectangular.png}
	\caption{Een equidistante cilinderprojectie.}
	\label{fig:eq-cilinder}
\end{figure}

Het verschil tussen een mono en stereo afbeelding is zoals er in hoofdstuk \ref{subsec:stereoscopie} werd gesproken over stereoscopie. Bij mono gaat men dus maar 1 afbeelding gaan tonen vanaf 1 perspectief terwijl men bij stereo 2 afbeelding vanaf een verschillend perspectief gaat tonen om dieptezicht mogelijk te maken. Bij React 360 is dit mogelijk door de afbeelding voor het linkse oog vanboven (of links bij 180°) te zetten en de afbeelding voor het rechtse oog aan de onderkant (of rechts bij 180°) te zetten en dit dan in 1 afbeelding te plaatsen. Het is natuurlijk enkel mogelijk om stereoafbeeldingen te bekijken met een 3D headset. Indien de gebruiker dus de applicatie zou uitvoeren zonder een VR headset dan kan men enkel hetgeen zien wat men in het linkse oog zou zien.

\subsubsection{Panorama foto's video's tonen}
Je kan foto's of video's zowel in de runtime (\ref{sec:werking-react360}) als in de React zelf gaan tonen. Dit kan je voor afbeeldingen doen in de runtime met volgende code:

\begin{lstlisting}[frame=single, caption=Een afbeelding als achtergrond instellen in de runtime.]
r360.compositor.setBackground('./static_assets/image.jpg', {
	format: '2D',
});
\end{lstlisting}

Zoals je kan zien is dit zeer gemakkelijk en vanzelfsprekend, maar is er wel een extra argument nodig namelijk het formaat. Er zijn 4 mogelijke formaten die je kan opgeven als argument in de code die overeenstemmen met de eerder genoemde formaten:

\begin{itemize}
	\item \textbf{2D} voor mono afbeeldingen/video's 
	\item \textbf{3DTB} voor stereo afbeelding/video's waarbij de afbeelding voor het links oog vanboven staat en de afbeelding voor het rechtse oog vanonder.
	\item \textbf{3DBT} voor stereo afbeelding/video's waarbij de afbeelding voor het rechtse oog vanboven staat en de afbeelding voor het linkse oog vanonder.
	\item \textbf{3DLR} voor stereo afbeelding/video's waarbij de afbeelding voor het links oog links staat en de afbeelding voor het rechtse oog rechts.
\end{itemize}

Om video's af te spelen volgen we een gelijkaardig proces. Hier heb je dus ook de keuze om die in de runtime of in React te gaan doen. Het grote verschil dan bij een afbeelding is dat je hier in 2 delen zal gaan werken. Eerst ga je de videospeler gaan aanmaken die een unieke naam moet krijgen en dan ga je deze videospeler gaan instellen als achtergrond.


\subsection{Het ruimtelijke systeem}
\label{subsec:ruimtelijk-systeem}
Het grootste verschil met een gewone webapplicatie en een VR applicatie is dat deze VR applicaties zich in een 3D ruimte bevinden. Er moet dus niet enkel worden rekening gehouden met hoogte en breedte maar dus ook met diepte. Dit kan al vrij snel ingewikkeld worden maar React 360 heeft ervoor gezorgd dat dit een pak makkelijker gaat

\subsubsection{Surfaces}
\label{ssubsec:surfaces}
Surfaces (oppervlaktes) bieden de mogelijkheid om 2D user interfaces in een 3D wereld te gaan stoppen. Je kan het gaan vergelijken met een stuk van een webpagina in een 3D wereld te gaan stoppen. Dit zorgt ervoor dat het dus een pak makkelijk is voor een ontwikkelaar om een ingewikkelde interface in React 360 te kunnen maken. In de code ziet een surface er zo uit:

\begin{lstlisting}[frame=single, caption=Voorbeeld van een surface]
import {Surface} from 'react-360-web';

const eenSurface = new Surface(
		500,
		400,
		Surface.SurfaceShape.Cylinder
	);
\end{lstlisting}

Er wordt dus een breedte (500) en een hoogte (400) voor de surface gedifinieerd. Daarnaast wordt er ook nog een vorm toegevoegd als argument. Je hebt 2 vormen van een surface, namelijk een 'Cylinder' of 'Flat' surface. Bij een cylinder surface gaat men dus de 2D inhoud gaan projecten in de vorm van een cylinder, rondom de gebruiker. Het grote voordeel hieraan is is dat je vanaf elk perspectief je recht op de 2D interface gaat kijken. Bij een flat of vlakke surface gaat men de 2D interface dan zoals de naam zegt, vlak gaan plaatsen. Het grote verschil is dus dat de inhoud niet altijd van hetzelfde perspectief wordt bekeken.

Surfaces zijn zeer flexibel. Je kan ze gemakkelijk gaan bewerken door functies zoals \lstinline[basicstyle=\ttfamily\color{red}]|setShape| te gaan gebruiken waarbij je de surface van een cylinder naar een vlakke surface kan aanpassen of omgekerd. Ook de hoogte en breedte van surfaces kan je perfect in React aanpassen. Het is dus ook perfect mogelijk om meerdere surfaces naast mekaar te gaan gebruiken of om eventueel ook meerdere componenten in 1 surface te gaan stoppen. 

Aangezien er meerdere componenten kunnen worden gestopt in 1 surface is er ook nood aan een duidelijke manier om deze componenten te ordenen. Dit is net hetzelfde als dat bij React Native wordt gebruikt namelijk flexbox. Flexbox wordt ook al veel gebruikt in gewone webpagina's en zorgt vooral voor een consistente layout op alle schermgroottes.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\linewidth]{flexbox.png}
	\caption{Een flexbox container met flex items.}
	\label{fig:flexbox}
\end{figure}

\subsubsection{3D-objecten}
\label{ssubsec:3d-objecten}
Het is ook mogelijk om 3D objecten te gaan gebruiken in React 360. Dit zijn objecten die op voorhand al gemaakt zijn in een ander programma van het formaat .obj, .mtl of .gltf2.

Het verschil met 3D objecten en 2D user interfaces is dat deze niet aan een surface moeten worden toegevoegd maar aan een 'Location'. Deze locations zijn eigenlijk gewoonweg punten in de omgeving waar je de 3D objecten kan gaan plaatsen. Deze gaan declareren in de code lijkt ook  veel op het declareren van een surface, enkel hier is er ook nood aan de X, Y en Z coördinaten. Waarbij X+ dus hetgeen rechts van de gebruiker voorstelt, Y+ de hoogte en Z+ hetgeen achter de gebruiker. De eenheid die hier gebruikt wordt is meter.

\begin{lstlisting}[frame=single, caption=Voorbeeld van een surface]
import {Location} from 'react-360-web';

const location = new Location([0, -1, -2]);
\end{lstlisting}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\linewidth]{3daxis.png}
	\caption{De X, Y en Z assen.}
	\label{fig:xyz-axis}
\end{figure}

Om 3D objecten van de opgenoemde formaten in onze applicatie te krijgen moeten we gebruik maken an het Entity component. Met dit component kunnen we dan ook de grootte en richting van dit 3D object gaan aanpassen. Dit gebeurt door \lstinline[basicstyle=\ttfamily\color{red}]|translate| of \lstinline[basicstyle=\ttfamily\color{red}]|rotateX|/\lstinline[basicstyle=\ttfamily\color{red}]|rotateY|\lstinline[basicstyle=\ttfamily\color{red}]|rotateZ| toe te voegen aan het entity component. Bij rotate worden dan de graden opgegeven en bij translate de coordinaten ten opzichte van de gebruiker. Dit is heel gemakkelijk om in code te gaan gebruiken:

\begin{lstlisting}[frame=single, caption=Voorbeeld van een Entity component]
<Entity 
	style={{transform: [
		{translate: [0, 0, -1]},
		{rotateY: 90}
		]}}>
	source={{obj: asset('een3DObject.obj')}}
/>
\end{lstlisting}

Hierbij draaien we dus het 3D object met 90 graden volgens de Y as en verplaatsen we het -1 meter volgens de Z as. Nu zal het object dus voor ons tevoorschijn komen.

\subsection{Geluid}
\label{subsec:Geluid}
Net zoals het mogelijk is om afbeeldingen en video's op de achtergrond te gebruiken is het ook perfect mogelijk om de applicatie van achtergrond geluid te voorzien en ook net zoals bij videos, kan je functies gaan uitvoeren die het volume kunnen aanpassen, audio dempen, ... De implementatie hiervan is ook zeer gelijkaardig:

\begin{lstlisting}[frame=single, caption=Voorbeeld van een Entity component]
import { asset, NativeModules } from 'react-360';
const { AudioModule } = NativeModules;

AudioModule.playEnvironmental({
	source: asset('audio.mp3'),
});
\end{lstlisting}

Omdat een virtual reality wereld steeds moet communiceren in 2 richtingen is het ook belangrijk dat bepaalde interacties met de wereld voldoende feedback tonen. Het is daarom in React 360 ook mogelijk om een 'One-shot audio' gebruiken. Dit kan je doen door \lstinline[basicstyle=\ttfamily\color{red}]|AudioModule.playOneShot| te gebruiken met de verwijzing naar de audio file als parameter. Je kan het dus perfect gaan gebruiken bij een functie die wordt opgeroepen door de \lstinline[basicstyle=\ttfamily\color{red}]|onClick| van een button.

Aangezien VR zich in een 3D omgeving bevindt. Is het ook mogelijk om aan een geluid een parameter \lstinline[basicstyle=\ttfamily\color{red}]|is3d| toe te voegen met de bijhorende locatie (x,y,z) van het geluid. Hierdoor zal het geluid zich specifiek vanaf die locatie afspelen.


\subsection{Input}
\label{subsec:input-vr}
De interactie met de wereld in virtual reality is natuurlijk zeer belangrijk. Maar er zijn ook vele mogelijkheden om input door te sturen naar de virtuele wereld waar we al over gesproken hebben in hoofdstuk \ref{subsec:interactie-vr} Hiervoor biedt React 360 meerdere oplossingen aan zodat de ontwikkelaar zich vooral kan focussen op de logica van de applicatie.

\subsubsection{Button input}
Met de titel bedoelt men niet noodzakelijk een \lstinline[basicstyle=\ttfamily\color{red}]|<button>| element als input, maar eerder een fysieke knop als input. Een toetsenbord, muis, controller, ... hebben allemaal fysieke knoppen ter beschikking. Als deze knoppen worden ingedrukt verwacht de gebruiker dus een bepaalde feedback van de VR applicatie. Om dit gemakkelijk te kunnen afhandelen voor alle input mogelijkheden biedt React 360 een \lstinline[basicstyle=\ttfamily\color{red}]|onInput| prop aan. Dit is zoals onClick een event handler, maar hierbij wordt dan de zogenaamde \lstinline[basicstyle=\ttfamily\color{red}]|inputEvent| meegestuurd. Dit is een eigenschap van het event dat werd verstuurd waarmee de verschillende acties kunnen worden geïdentificeerd. Zowel de knop (boven, onder, links, rechts, ok, ...) en de actie (knop indrukken, knop terug omhoog) die wordt uitgevoerd worden teruggeven. Het maakt dus niet uit welk input toestel je gebruikt, als er een naar onder wordt gedetecteerd zal React 360 de juiste knop en actie terugsturen waardoor het dus mogelijk is voor de ontwikkelaar om de correcte code hiervoor te schrijven. Dit toont zeer duidelijk de cross-platform mogelijkheden aan van React 360 en spaart voor de ontwikkelaar een hoop tijd uit dan moest hij dit voor elk apparaat individueel moeten programmeren.

\subsubsection{VrButton}
Het VrButton component is eigenlijk niet meer dan een button waarbij er wordt gereageerd op de 'confirm' actie. Deze actie komt regelmatig terug. Dit component is dus louter om het gemakkelijker voor de ontwikkelaar te maken. Het enigste verschil is dat hier een \lstinline[basicstyle=\ttfamily\color{red}]|onClick| event handler kan toegevoegd worden.

\subsubsection{Cursors en raycasters}
Je kan niet correct op de virtuele wereld interacties uit voeren, als je niet weet waar je de interacties precies uitvoert. React 360 gebruikt hiervoor cursors, net zoals je op een gewoon computerscherm een cursor hebt. Sommige controllers worden standaard in React 360 ondersteund. Deze tonen dan een soort van laserstraal in de wereld. De cursor wordt dan getoond op het element waar de laserstraal mee snijdt. Om hiervoor dan ook events op te kunnen uitvoeren, zijn de \lstinline[basicstyle=\ttfamily\color{red}]|onEnter| en \lstinline[basicstyle=\ttfamily\color{red}]|onExit| event handlers aanwezig. De \lstinline[basicstyle=\ttfamily\color{red}]|onEnter| wordt uitgevoerd vanaf dat de cursor het component binnentreedt. De \lstinline[basicstyle=\ttfamily\color{red}]|onExit| doet dan het omgekeerde en wordt opgeroepen als de cursor het component verlaat.

Omdat React 360 dus niet alle controllers ondersteund, is het ook mogelijk voor een ontwikkelaar om zelfs deze te gaan definiëren. Men noemt dit ook wel een raycaster. Een Raycaster moet een bepaalde interface gaan volgen om als raycaster te worden gezien.

\begin{itemize}
	\item De richting van de raycaster
	\item Of de raycaster een cursor moet tonen op het snijpunt
	\item Of de raycaster absoluut moet getoond worden tegenover de camera (positie van de persoon dus)
	\item De maximale lengte van de 'laserstraal' van de raycaster
	\item Het punt waar de raycaster begint
	\item Het type raycaster (touch, mouse, ..)
\end{itemize}